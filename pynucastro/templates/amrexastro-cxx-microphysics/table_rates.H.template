#ifndef TABLE_RATES_H
#define TABLE_RATES_H

#include <iostream>
#include <sstream>
#include <fstream>
#include <string>

#include <AMReX_Array.H>

using namespace amrex;

void init_tabular();

// Table is expected to be in terms of dens*ye and temp (logarithmic, cgs units)
// Table energy units are expected in terms of ergs

// all tables are expected to have columns:
// Log(rhoY)     Log(T)   mu    dQ    Vs    Log(e-cap-rate)   Log(nu-energy-loss)  Log(gamma-energy)
// Log(g/cm^3)   Log(K)   erg   erg   erg   Log(1/s)          Log(erg/s)           Log(erg/s)
//

<table_num>(0)

enum TableVars
{
    jtab_mu      = 1,
    jtab_dq      = 2,
    jtab_vs      = 3,
    jtab_rate    = 4,
    jtab_nuloss  = 5,
    jtab_gamma   = 6,
    num_vars = jtab_gamma
};


struct table_t
{
    int ntemp;
    int nrhoy;
    int nvars;
    int nheader;
};

// we add a 7th quantity dr/dT
// k_drate_dt is used only for calculating the derivative
// of rate with temperature from the table, it isn't an index
// into the table but into the 'entries' array in, eg. get_entries.

const int k_drate_dt   = 7;
const int add_vars     = 1;  // 1 Additional Var in entries


namespace rate_tables
{
<declare_tables>(1)
}

template <typename R, typename T, typename D>
void init_tab_info(const table_t& tf, const std::string& file, R& log_rhoy_table, T& log_temp_table, D& data) {

    std::ifstream table;
    table.open(file);

    std::string line;

    // read and skip over the header

    for (int i = 0; i < tf.nheader; ++i) {
        std::getline(table, line);
    }

    // now the data -- there are 2 extra columns, for log_temp and log_rhoy

    for (int j = 1; j <= tf.nrhoy; ++j) {
        for (int i = 1; i <= tf.ntemp; ++i) {
            std::getline(table, line);
            std::istringstream sdata(line);

            sdata >> log_rhoy_table(j) >> log_temp_table(i);

            for (int n = 1; n <= tf.nvars; ++n) {
                sdata >> data(i, j, n);
            }
        }
    }

    table.close();
}


template <typename V>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
int vector_index_lu(const int vlen, const V& vector, const Real fvar)
{

    // Returns the greatest index of vector for which vector(index) < fvar.
    // Return 1 if fvar < vector(1)
    // Return size(vector)-1 if fvar > vector(size(vector))
    // The interval [index, index+1] brackets fvar for fvar within the range of vector.

    int index;

    if (fvar < vector(1)) {
        index = 1;
    } else if (fvar > vector(vlen)) {
        index = vlen - 1;
    } else {
        int nup = vlen;
        int ndn = 1;
        for (int i = 1; i <= vlen; ++i) {
            int j = ndn + (nup - ndn)/2;
            if (fvar < vector(j)) {
                nup = j;
            } else {
                ndn = j;
            }
            if ((nup - ndn) == 1) {
                break;
            }
        }
        index = ndn;
    }

    return index;
}


AMREX_INLINE AMREX_GPU_HOST_DEVICE
Real
evaluate_linear_1d(Real fhi, Real flo, Real xhi, Real xlo, Real x)
{
    Real f;

    if (x <= xlo) {
        f = flo;
    } else if (x >= xhi) {
        f = fhi;
    } else {
        f = flo + (fhi - flo) * (x - xlo) / (xhi - xlo);
    }

    return f;
}

AMREX_INLINE AMREX_GPU_HOST_DEVICE
Real
evaluate_linear_2d(Real fip1jp1, Real fip1j, Real fijp1, Real fij,
          Real xhi, Real xlo, Real yhi, Real ylo,
          Real x, Real y)
{
    Real f;

    if ((x <= xlo) && (y <= ylo)) {
        f = fij;
    } else if ((x <= xlo) && (y >= yhi)) {
        f = fijp1;
    } else if ((x >= xhi) && (y <= ylo)) {
        f =fip1j;
    } else if ((x >= xhi) && (y <= ylo)) {
        f = fip1jp1;
    } else {

        Real dx = xhi - xlo;
        Real dy = yhi - ylo;

        Real E =  fij;
        Real C = (fijp1 - fij) / dx;
        Real B = (fip1j - fij) / dy;
        Real A = (fip1jp1 - B * dx - C * dy - E)/ (dx * dy);

        f =  A * (x - xlo) * (y - ylo) +
             B * (x - xlo) +
             C * (y - ylo) +
             E;
    }
    return f;
}


template<typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
Real
linear_interpolator(const table_t& table_meta, const R& log_rhoy_table, const T& log_temp_table, const D& data,
                    const Real rhoy, const Real temp, const int component)
{
    const Real log_rhoy = std::log10(rhoy);
    const Real log_temp = std::log10(temp);

    int jtemp_lo = vector_index_lu(table_meta.ntemp, log_temp_table, log_temp);
    int jtemp_hi = jtemp_lo + 1;

    int irhoy_lo = vector_index_lu(table_meta.nrhoy, log_rhoy_table, log_rhoy);
    int irhoy_hi = irhoy_lo + 1;

    Real rhoy_lo = log_rhoy_table(jtemp_lo);
    Real rhoy_hi = log_rhoy_table(jtemp_hi);

    Real t_lo = log_temp_table(jtemp_lo);
    Real t_hi = log_temp_table(jtemp_hi);

    Real fij = data(jtemp_lo, irhoy_lo, component);
    Real fip1j = data(jtemp_lo, irhoy_hi, component);
    Real fijp1 = data(jtemp_hi, irhoy_lo, component);
    Real fip1jp1 = data(jtemp_hi, irhoy_hi, component);

    Real r = evaluate_linear_2d(fip1jp1, fip1j, fijp1, fij,
                                rhoy_hi, rhoy_lo, t_hi, t_lo, log_rhoy, log_temp);

    return r;
}


template<typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
Real
evaluate_dr_dtemp(const table_t& table_meta, const R& log_rhoy_table, const T& log_temp_table, const D& data,
                  const Real rhoy, const Real temp)
{
    // The main objective of this function is compute dlogr_dlogt.

    const Real log_rhoy = std::log10(rhoy);
    const Real log_temp = std::log10(temp);

    int irhoy_lo = vector_index_lu(table_meta.nrhoy, log_rhoy_table, log_rhoy);
    int irhoy_hi = irhoy_lo + 1;

    int jtemp_lo = vector_index_lu(table_meta.ntemp, log_temp_table, log_temp);
    int jtemp_hi = jtemp_lo + 1;

    Real dlogr_dlogt;

    //Now we compute the forward finite difference on the boundary

    if ((jtemp_lo -1  < 1) || (jtemp_hi + 1 > table_meta.ntemp)) {

        // In this case we are in the boundaries of the table.
        // At the boundary, we compute the forward-j finite difference
        // to compute dlogr_dlogt_i and dlogr_dlogt_ip1, using the
        // following stencil:
        //
        //
        //             fijp1-----------fip1jp1
        //              |                 |
        //              |                 |
        //              |                 |
        //              |                 |
        //              |                 |
        //              |                 |
        //              |                 |
        //             fij-------------fip1j
        //
        // with the following result:
        //
        //            dlogr_dlogt_i --------dlogr_dlogt_ip1
        //
        // Finally, we perform a 1d-linear interpolation between dlogr_dlogt_ip1
        // and dlogr_dlogt_i to compute dlogr_dlogt

        Real rhoy_lo = log_temp_table(irhoy_lo);
        Real rhoy_hi = log_temp_table(irhoy_hi);

        Real t_lo = log_temp_table(jtemp_lo);
        Real t_hi = log_temp_table(jtemp_hi);

        Real fij     = data(jtemp_lo, irhoy_lo, jtab_rate);
        Real fip1j   = data(jtemp_lo, irhoy_hi, jtab_rate);
        Real fijp1   = data(jtemp_hi, irhoy_lo, jtab_rate);
        Real fip1jp1 = data(jtemp_hi, irhoy_hi, jtab_rate);

        Real dlogr_dlogt_i   = (fijp1 - fij) / (t_hi - t_lo);
        Real dlogr_dlogt_ip1 = (fip1jp1 - fip1j) / (t_hi - t_lo);

        dlogr_dlogt = evaluate_linear_1d(dlogr_dlogt_ip1, dlogr_dlogt_i, rhoy_hi, rhoy_lo, log_rhoy);

    } else {

        // In this case, we use a bigger stencil to reconstruct the
        // temperature derivatives in the j and j+1 temperature positions,
        // using the cetral-j finite differences:
        //
        //              fijp2 ------------fip1jp2
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //               fijp1------------fip1jp1
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //               fij------------- fip1j
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //               fijm1------------fip1jm1
        //
        // with the following result:
        //
        //
        //            dr_dt_ijp1 --------dr_dt_ip1jp1
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //                |                 |
        //            dr_dt_ij-----------dr_dt_ip1j
        //
        // Finally, we perform a 2d-linear interpolation to
        // compute dlogr_dlogt.

        Real t_jm1  = log_temp_table(jtemp_lo-1);
        Real t_j    = log_temp_table(jtemp_lo);
        Real t_jp1  = log_temp_table(jtemp_hi);
        Real t_jp2  = log_temp_table(jtemp_hi+1);

        Real rhoy_lo = log_rhoy_table(irhoy_lo);
        Real rhoy_hi = log_rhoy_table(irhoy_hi);

        Real fijm1   = data(jtemp_lo-1, irhoy_lo, jtab_rate);
        Real fij     = data(jtemp_lo, irhoy_lo, jtab_rate);
        Real fijp1   = data(jtemp_hi, irhoy_lo, jtab_rate);
        Real fijp2   = data(jtemp_hi+1, irhoy_lo, jtab_rate);

        Real fip1jm1 = data(jtemp_lo-1, irhoy_hi, jtab_rate);
        Real fip1j   = data(jtemp_lo, irhoy_hi, jtab_rate);
        Real fip1jp1 = data(jtemp_hi, irhoy_hi, jtab_rate);
        Real fip1jp2 = data(jtemp_hi+1, irhoy_hi, jtab_rate);

        Real dlogr_dlogt_ij     = (fijp1 - fijm1)/(t_jp1 - t_jm1);
        Real dlogr_dlogt_ijp1   = (fijp2 - fij)/(t_jp2 - t_j);
        Real dlogr_dlogt_ip1j   = (fip1jp1 - fip1jm1)/(t_jp1 - t_jm1);
        Real dlogr_dlogt_ip1jp1 = (fip1jp2 - fip1j)/(t_jp2 - t_j);

        dlogr_dlogt = evaluate_linear_2d(dlogr_dlogt_ip1jp1,  dlogr_dlogt_ip1j, dlogr_dlogt_ijp1, dlogr_dlogt_ij,
                                rhoy_hi, rhoy_lo, t_jp1, t_j,
                                log_rhoy, log_temp);

    }

    return dlogr_dlogt;
}


template <typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
void
get_entries(const table_t& table_meta, const R& log_rhoy_table, const T& log_temp_table, const D& data,
            const Real rhoy, const Real temp, Array1D<Real, 1, num_vars+1>& entries)
{

    entries(jtab_rate)   = linear_interpolator(table_meta, log_rhoy_table, log_temp_table, data,
                                            rhoy, temp, jtab_rate);

    entries(k_drate_dt)  = evaluate_dr_dtemp(table_meta, log_rhoy_table, log_temp_table, data,
                                            rhoy, temp);

    entries(jtab_nuloss) = linear_interpolator(table_meta, log_rhoy_table, log_temp_table, data,
                                            rhoy, temp, jtab_nuloss);

    entries(jtab_gamma)  = linear_interpolator(table_meta, log_rhoy_table, log_temp_table, data,
                                            rhoy, temp, jtab_gamma);

}

template <typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
void
tabular_evaluate(const table_t& table_meta,
                 const R& rhoy_table, const T& temp_table, const D& data,
                 const Real rhoy, const Real temp,
                 Real& rate, Real& drate_dt, Real& edot_nu, Real& edot_gamma)
{
    Array1D<Real, 1, num_vars+1> entries;

    // Get the table entries at this rhoy, temp

    get_entries(table_meta, rhoy_table, temp_table, data,
                rhoy, temp, entries);

    // Fill outputs: rate, d(rate)/d(temperature), and
    // (negative) neutrino loss contribution to energy generation

    rate       = std::pow(10.0_rt, entries(jtab_rate));
    drate_dt   = rate * entries(k_drate_dt) / temp;
    edot_nu    = -std::pow(10.0_rt, entries(jtab_nuloss));
    edot_gamma = std::pow(10.0_rt, entries(jtab_gamma));
}

#endif
