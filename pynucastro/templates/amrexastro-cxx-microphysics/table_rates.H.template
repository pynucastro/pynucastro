#ifndef TABLE_RATES_H
#define TABLE_RATES_H

#include <iostream>
#include <sstream>
#include <fstream>
#include <string>

#include <AMReX_Array.H>

using namespace amrex;

void init_tabular();

// Table is expected to be in terms of dens*ye and temp (logarithmic, cgs units)
// Table energy units are expected in terms of ergs

// all tables are expected to have columns:
// Log(rhoY)     Log(T)   Log(mu)    Log(dQ)    Log(Vs)    Log(e-cap-rate)   Log(nu-energy-loss)  Log(gamma-energy)
// Log(g/cm^3)   Log(K)   Log(erg)   Log(erg)   Log(erg)   Log(1/s)          Log(erg/s)           Log(erg/s)
//

<table_num>(0)

enum TableVars
{
    jtab_mu      = 1,
    jtab_dq      = 2,
    jtab_vs      = 3,
    jtab_rate    = 4,
    jtab_nuloss  = 5,
    jtab_gamma   = 6,
    num_vars = jtab_gamma
};


struct table_t
{
    int ntemp;
    int nrhoy;
    int nvars;
    int nheader;
};

// we add a 7th index, k_index_dlogr_dlogt used for computing the derivative
// of Log(rate) with respect of Log(temperature) by using the table
// values. It isn't an index into the table but into the 'entries'
// array. Is important to mention that although we compute dlogr/dlogT is
// the computed quantity in 'entries', we pursue ultimately
// dr/dt as the final desired quantity to be computed for this index.

const int  k_index_dlogr_dlogt  = 7;
const int add_vars              = 1;  // 1 Additional Var in entries


namespace rate_tables
{
<declare_tables>(1)
}

template <typename R, typename T, typename D>
void init_tab_info(const table_t& tf, const std::string& file, R& log_rhoy, T& log_temp, D& data) {

    // This function initializes the selected tabular-rate tables. From the tables we are interested
    // on the rate, neutrino-energy-loss and the gamma-energy entries.

    std::ifstream table;
    table.open(file);

    std::string line;

    // read and skip over the header

    for (int i = 0; i < tf.nheader; ++i) {
        std::getline(table, line);
    }

    // now the data -- there are 2 extra columns, for temp and rhoy

    for (int j = 1; j <= tf.nrhoy; ++j) {
        for (int i = 1; i <= tf.ntemp; ++i) {
            std::getline(table, line);
            std::istringstream sdata(line);

            sdata >> log_rhoy(j) >> log_temp(i);

            for (int n = 1; n <= tf.nvars; ++n) {
                sdata >> data(i, j, n);
            }
        }
    }

    table.close();
}


template <typename V>
AMREX_GPU_HOST_DEVICE AMREX_INLINE
int vector_index_lu(const int vlen, const V& vector, const Real fvar)
{

    // Returns the greatest index of vector for which vector(index) < fvar.
    // Return 1 if fvar < vector(1)
    // Return size(vector)-1 if fvar > vector(size(vector))
    // The interval [index, index+1] brackets fvar for fvar within the range of vector.

    int index;

    if (fvar < vector(1)) {
        index = 1;
    } else if (fvar > vector(vlen)) {
        index = vlen - 1;
    } else {
        int nup = vlen;
        int ndn = 1;
        for (int i = 1; i <= vlen; ++i) {
            int j = ndn + (nup - ndn)/2;
            if (fvar < vector(j)) {
                nup = j;
            } else {
                ndn = j;
            }
            if ((nup - ndn) == 1) {
                break;
            }
        }
        index = ndn;
    }

    return index;
}


AMREX_INLINE AMREX_GPU_HOST_DEVICE
Real
bl_clamp(const Real xlo, const Real xhi, const Real flo, const Real fhi, const Real x)
{

    // Perform bilinear interpolation within the interval [xlo, xhi]
    // where the function values at the endpoints are defined by:
    // flo = f(xlo)
    // fhi = f(xhi)
    // Returns f(x), the values flo and fhi interpolated at x
    // f(x) = flo if x <= xlo
    // f(x) = fhi if x >= xhi

    Real f;
    Real xx = Clamp(x, xlo, xhi);

    f = (flo * (xhi - xx) + fhi * (xx - xlo) ) / (xhi - xlo);

    return f;
}


template <typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
void
get_entries(const table_t& table_meta,
            const R& log_rhoy_table, const T& log_temp_table, const D& data,
            const Real rhoy, const Real temp, Array1D<Real, 1, num_vars+1>& entries)
{

    // Translate bare rho * Ye and temp physical quantities into its Log form

    const Real log_rhoy = std::log10(rhoy);
    const Real log_temp = std::log10(temp);

    // The last element of entries is the derivative of rate with temperature
    // drate_dt, evaluated by central differencing at the box corners
    // and then performing a bilinear interpolation on those central differences.


    // Get box-corner points for interpolation
    // This deals with out-of-range inputs via linear extrapolation

    int irhoy_lo = vector_index_lu(table_meta.nrhoy, log_rhoy_table, log_rhoy);
    int itemp_lo = vector_index_lu(table_meta.ntemp, log_temp_table, log_temp);

    int irhoy_hi = irhoy_lo + 1;
    int itemp_hi = itemp_lo + 1;

    // Bilinear interpolation within the box
    // The desired point is denoted by ABCD, within the box.
    // The value of ivar at ABCD is denoted by fvar.
    //
    //Log(T) ^   B .      . C
    //       |
    //       |  AB   ABCD   CD
    //       |     .      .
    //       |   A          D
    //       |___________________> Log(rho*Ye)

    Real log_temp_lo = log_temp_table(itemp_lo);
    Real log_temp_hi = log_temp_table(itemp_hi);

    Real log_rhoy_lo = log_rhoy_table(irhoy_lo);
    Real log_rhoy_hi = log_rhoy_table(irhoy_hi);

    // Interpolate for each table entry

    for (int ivar = 1; ivar <= num_vars; ivar++) {
        Real f_i = bl_clamp(log_temp_lo, log_temp_hi,
                             data(itemp_lo, irhoy_lo, ivar),
                             data(itemp_hi, irhoy_lo, ivar),
                             log_temp);

        Real f_ip1 = bl_clamp(log_temp_lo, log_temp_hi,
                               data(itemp_lo, irhoy_hi, ivar),
                               data(itemp_hi, irhoy_hi, ivar),
                               log_temp);

        // NOLINTNEXTLINE(readability-suspicious-call-argument)
        entries(ivar) = bl_clamp(log_rhoy_lo, log_rhoy_hi, f_i, f_ip1, log_rhoy);
    }

    // Calculate the derivative of rate with temperature, d(rate)/d(t)
    // (Clamp interpolations in rhoy to avoid unphysical temperature derivatives)

    if ((itemp_lo - 1 < 1) || (itemp_hi + 1 > table_meta.ntemp)) {
        // We're at the first or last table cell (in temperature)
        // First do linear interpolation in rhoy for the table at tlo and thi

        Real f_i = bl_clamp(log_rhoy_lo, log_rhoy_hi,
                            data(itemp_lo, irhoy_lo, jtab_rate),
                            data(itemp_lo, irhoy_hi, jtab_rate),
                            log_rhoy);

        Real f_ip1 = bl_clamp(log_rhoy_lo, log_rhoy_hi,
                              data(itemp_hi, irhoy_lo, jtab_rate),
                              data(itemp_hi, irhoy_hi, jtab_rate),
                              log_rhoy);

        // Approximate d(log(rate))/d(log(t)) via forward differencing on the boundary
        // index position and by zero outside the domain.

        if ((log_temp < log_temp_lo) || (log_temp > log_temp_hi)) {
            entries(k_index_dlogr_dlogt) = 0.0_rt;
        } else {
            entries(k_index_dlogr_dlogt) = (f_ip1 - f_i) / (log_temp_hi - log_temp_lo);
        }

    } else {
        // Approximate d(log(rate))/d(log(t)) via bilinear interpolation on central differences

        Real log_temp_im1 = log_temp_table(itemp_lo-1);
        Real log_temp_i   = log_temp_table(itemp_lo);
        Real log_temp_ip1 = log_temp_table(itemp_hi);
        Real log_temp_ip2 = log_temp_table(itemp_hi+1);

        Real f_im1 = bl_clamp(log_rhoy_lo, log_rhoy_hi,
                              data(itemp_lo-1, irhoy_lo, jtab_rate),
                              data(itemp_lo-1, irhoy_hi, jtab_rate),
                              log_rhoy);

        Real f_i = bl_clamp(log_rhoy_lo, log_rhoy_hi,
                            data(itemp_lo, irhoy_lo, jtab_rate),
                            data(itemp_lo, irhoy_hi, jtab_rate),
                            log_rhoy);

        Real f_ip1 = bl_clamp(log_rhoy_lo, log_rhoy_hi,
                              data(itemp_hi, irhoy_lo, jtab_rate),
                              data(itemp_hi, irhoy_hi, jtab_rate),
                              log_rhoy);

        Real f_ip2 = bl_clamp(log_rhoy_lo, log_rhoy_hi,
                              data(itemp_hi+1, irhoy_lo, jtab_rate),
                              data(itemp_hi+1, irhoy_hi, jtab_rate),
                              log_rhoy);

        // Get central difference derivatives at the box corners

        Real dlogr_dlogt_i   = (f_ip1 - f_im1) / (log_temp_ip1 - log_temp_im1);
        Real dlogr_dlogt_ip1 = (f_ip2 - f_i)   / (log_temp_ip2 - log_temp_i);

        // Interpolate in temperature

        entries(k_index_dlogr_dlogt) = bl_clamp(log_temp_i, log_temp_ip1,
                                                dlogr_dlogt_i, dlogr_dlogt_ip1, log_temp);

    }
}


template <typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
void
tabular_evaluate(const table_t& table_meta,
                 const R& log_rhoy_table, const T& log_temp_table, const D& data,
                 const Real rhoy, const Real temp,
                 Real& rate, Real& drate_dt, Real& edot_nu, Real& edot_gamma)
{


    Array1D<Real, 1, num_vars+1> entries;

    // Get the table entries at this rhoy, temp

    get_entries(table_meta, log_rhoy_table, log_temp_table, data,
                rhoy, temp, entries);

    // Fill outputs: rate, d(rate)/d(temperature), and
    // (negative) neutrino loss contribution to energy generation

    rate       = std::pow(10.0_rt, entries(jtab_rate));
    drate_dt   = rate * entries(k_index_dlogr_dlogt) / temp;
    edot_nu    = -std::pow(10.0_rt, entries(jtab_nuloss));
    edot_gamma = std::pow(10.0_rt, entries(jtab_gamma));
}

#endif
