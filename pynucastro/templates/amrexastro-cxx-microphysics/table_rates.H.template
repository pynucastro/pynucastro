#ifndef TABLE_RATES_H
#define TABLE_RATES_H

#include <iostream>
#include <sstream>
#include <fstream>
#include <string>

#include <AMReX_Array.H>

using namespace amrex;

void init_tabular();

// Table is expected to be in terms of dens*ye and temp (non-logarithmic, cgs units)
// Table energy units are expected in terms of ergs

// all tables are expected to have columns:
// Log(rhoY)     Log(T)   mu    dQ    Vs    Log(e-cap-rate)   Log(nu-energy-loss)  Log(gamma-energy)
// Log(g/cm^3)   Log(K)   erg   erg   erg   Log(1/s)          Log(erg/s)           Log(erg/s)
//

<table_num>(0)

enum TableVars
{
    jtab_mu      = 1,
    jtab_dq      = 2,
    jtab_vs      = 3,
    jtab_rate    = 4,
    jtab_nuloss  = 5,
    jtab_gamma   = 6,
    num_vars = jtab_gamma
};


struct table_t
{
    int ntemp;
    int nrhoy;
    int nvars;
    int nheader;
};

// we add a 7th quantity dr/dT
// k_drate_dt is used only for calculating the derivative
// of rate with temperature from the table, it isn't an index
// into the table but into the 'entries' array in, eg. get_entries.

const int k_drate_dt   = 7;
const int add_vars     = 1;  // 1 Additional Var in entries


namespace rate_tables
{
<declare_tables>(1)
}

template <typename R, typename T, typename D>
void init_tab_info(const table_t& tf, const std::string& file, R& log_rhoy, T& log_temp, D& data) {

    std::ifstream table;
    table.open(file);

    std::string line;

    // read and skip over the header

    for (int i = 0; i < tf.nheader; ++i) {
        std::getline(table, line);
    }

    // now the data -- there are 2 extra columns, for log_temp and log_rhoy

    for (int j = 1; j <= tf.nrhoy; ++j) {
        for (int i = 1; i <= tf.ntemp; ++i) {
            std::getline(table, line);
            std::istringstream sdata(line);

            sdata >> log_rhoy(j) >> log_temp(i);

            for (int n = 1; n <= tf.nvars; ++n) {
                sdata >> data(i, j, n);
            }
        }
    }

    table.close();
}


template <typename V>
AMREX_GPU_HOST_DEVICE AMREX_INLINE
int vector_index_lu(const int vlen, const V& vector, const Real fvar)
{

    // Returns the greatest index of vector for which vector(index) < fvar.
    // Return 1 if fvar < vector(1)
    // Return size(vector)-1 if fvar > vector(size(vector))
    // The interval [index, index+1] brackets fvar for fvar within the range of vector.

    int index;

    if (fvar < vector(1)) {
        index = 1;
    } else if (fvar > vector(vlen)) {
        index = vlen - 1;
    } else {
        int nup = vlen;
        int ndn = 1;
        for (int i = 1; i <= vlen; ++i) {
            int j = ndn + (nup - ndn)/2;
            if (fvar < vector(j)) {
                nup = j;
            } else {
                ndn = j;
            }
            if ((nup - ndn) == 1) {
                break;
            }
        }
        index = ndn;
    }

    return index;
}


template<typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
Real
linear_interpolator(const table_t& table_meta, const R& log_rho_table, const T& log_temp_table, const D& data,
                    const Real rhoy, const Real temp, const int component)
{
    const Real log_rhoy = std::log10(rhoy);
    const Real log_temp = std::log10(temp);

    int irhoy = vector_index_lu(table_meta.nrhoy, log_rho_table, log_rhoy);
    int jtemp = vector_index_lu(table_meta.ntemp, log_temp_table, log_temp);

    const Real dlog_rhoy = log_rho_table(irhoy+1) - log_rho_table(irhoy);
    const Real dlog_temp = log_temp_table(jtemp+1) - log_temp_table(jtemp);

    Real fij = data(jtemp, irhoy, component);
    Real fip1j = data(jtemp, irhoy+1, component);
    Real fijp1 = data(jtemp+1, irhoy, component);
    Real fip1jp1 = data(jtemp+1, irhoy+1, component);

    Real D =  fij;
    Real C = (fijp1 - fij) / dlog_rhoy;
    Real B = (fip1j - fij) / dlog_temp;
    Real A = (fip1jp1 - B * dlog_rhoy - C * dlog_temp - D) / (dlog_rhoy * dlog_temp);

    Real r =  A * (log_rhoy - log_rho_table(irhoy)) * (log_temp - log_temp_table(jtemp)) +
              B * (log_rhoy - log_rho_table(irhoy)) +
              C * (log_temp - log_temp_table(jtemp)) +
              D;

    return r;
}


template<typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
Real
evaluate_dr_dtemp(const table_t& table_meta, const R& log_rho_table, const T& log_temp_table, const D& data,
                  const Real rhoy, const Real temp)
{
    //Now we compute dlogr_dlogT

    const Real log_rhoy = std::log10(rhoy);
    const Real log_temp = std::log10(temp);

    int irhoy = vector_index_lu(table_meta.nrhoy, log_rho_table, log_rhoy);
    int jtemp = vector_index_lu(table_meta.ntemp, log_temp_table, log_temp);

    const Real dlog_rhoy = log_rho_table(irhoy+1) - log_rho_table(irhoy);
    const Real dlog_temp = log_temp_table(jtemp+1) - log_temp_table(jtemp);

    Real t_jm1 = log_temp_table(jtemp-1);
    Real t_j = log_temp_table(jtemp);
    Real t_jp1 = log_temp_table(jtemp+1);
    Real t_jp2 = log_temp_table(jtemp+2);

    Real fijm1 = data(jtemp-1, irhoy, jtab_rate);
    Real fij = data(jtemp, irhoy, jtab_rate);
    Real fijp1 = data(jtemp+1, irhoy, jtab_rate);
    Real fijp2 = data(jtemp+2, irhoy, jtab_rate);

    Real fip1jm1 = data(jtemp-1, irhoy+1, jtab_rate);
    Real fip1j = data(jtemp, irhoy+1, jtab_rate);
    Real fip1jp1 = data(jtemp+1, irhoy+1, jtab_rate);
    Real fip1jp2 = data(jtemp+2, irhoy+1, jtab_rate);

    //Now we compute the central differences within the boundaries
    //or the the forward differences on the boundaries

    if ((jtemp - 1) < 1 || (jtemp + 2) > table_meta.ntemp) {

        Real dr_dt_ij = (fijp1 - fij)/(t_jp1 - t_j);
        Real dr_dt_ijp1 = (fijp2 - fijp1)/(t_jp2 - t_jp1);
        Real dr_dt_ip1j = (fip1jp1 - fip1j)/(t_jp1 - t_j);
        Real dr_dt_ip1jp1 = (fip1jp2 - fip1jp1)/(t_jp2 - t_jp1);

    } else {

        Real dr_dt_ij = (fijp1 - fijm1)/(t_ijp1 - t_ijm1);
        Real dr_dt_ijp1 = (fijp2 - fij)/(t_ijp2 - t_ij);
        Real dr_dt_ip1j = (fip1jp1 - fip1jm1)/(t_ijp1 - t_ijm1);
        Real dr_dt_ip1jp1 = (fip1jp2 - fip1j)/(t_ijp2 - t_ij);

    }

    //And interpolate through all the derivatives:

    Real D = dr_dt_ij;
    Real C = (dr_dt_ijp1 - dr_dt_ij) / dlog_rhoy;
    Real B = (dr_dt_ip1j - dr_dt_ij) / dlog_temp;
    Real A = (dr_dt_ip1jp1 - B * dlog_rhoy - C * dlog_temp - D) / (dlog_rhoy * dlog_temp);

    Real dlogr_dlogT =  A * (log_rhoy - log_rho_table(irhoy)) * (log_temp - log_temp_table(jtemp)) +
                        B * (log_rhoy - log_rho_table(irhoy)) +
                        C * (log_temp - log_temp_table(jtemp)) +
                        D;

    return dlogr_dlogT;
}

template <typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
void
get_entries(const table_t& table_meta, const R& log_rho_table, const T& log_temp_table, const D& data,
            const Real rhoy, const Real temp, Array1D<Real, 1, num_vars+1>& entries);
{

    entries(jtab_rate)   = linear_interpolator(table_meta, log_rho_table, log_temp_table, data,
                                            rhoy, temp, jtab_rate);

    entries(k_drate_dt)  = evaluate_dr_dtemp(table_meta, log_rho_table, log_temp_table, data,
                                            rhoy, temp);

    entries(jtab_nuloss) = linear_interpolator(table_meta, log_rho_table, log_temp_table, data,
                                            rhoy, temp, jtab_nuloss);

    entries(jtab_gamma)  = linear_interpolator(table_meta, log_rho_table, log_temp_table, data,
                                            rhoy, temp, jtab_gamma);

}

template <typename R, typename T, typename D>
AMREX_INLINE AMREX_GPU_HOST_DEVICE
void
tabular_evaluate(const table_t& table_meta,
                 const R& rhoy_table, const T& temp_table, const D& data,
                 const Real rhoy, const Real temp,
                 Real& rate, Real& drate_dt, Real& edot_nu, Real& edot_gamma)
{
    Array1D<Real, 1, num_vars+1> entries;

    // Get the table entries at this rhoy, temp

    get_entries(table_meta, rhoy_table, temp_table, data,
                rhoy, temp, entries);

    // Fill outputs: rate, d(rate)/d(temperature), and
    // (negative) neutrino loss contribution to energy generation

    rate       = entries(jtab_rate);
    drate_dt   = entries(k_drate_dt);
    edot_nu    = -entries(jtab_nuloss);
    edot_gamma = entries(jtab_gamma);
}

#endif
